# File Caching Proxy System

This is a concurrent file system with a caching proxy, written for 15-640 
Distributed Systems course at Carnegie Mellon University. This system is using 
Open-Close session semantics just like the 
[Andrew File System (AFS)](https://en.wikipedia.org/wiki/Andrew_File_System). 
The build has received full points on all three checkpoints on Autolab. 

## Running the project

There are several ways to test and run the project. The easiest way is to run
by the pre-written shell scipts. 

This will compile and run the server.
````
source Server.sh
````
This will compile and run the proxy.
````
source Proxy.sh
````
These scripts will run tests on the whole file system. 
````
source run.sh
source slowReadA.sh
source writeLRUtest.sh
source basicLRUtest.sh
source advancedLRU.sh
````

Note: Preferably run on a 64-bit Linux or Unix system. 



## Caching Protocol between Server and Proxy

In this project, ”Check-on-use” is used where clients chat to server upon 
`open()` to check if the file copy in the cache is up-to-date. If it is a 
cache miss, or it is a cache hit but the version is not up-to-date, the proxy 
will download the file from proxy. Otherwise, if cache hit and the version 
is up-to-date, the client will directly interact with the file item in the 
local cache.

## LRU Caching Implementation

The LRU cache in this project is implemented by

 1. a concurrent hash map `cacheBlockMap`, mapping between the file path in cache (e.g. `A_9`) and the corresponding cache block.

 2. a doubly linked list for maintaining the order of the MRU to LRU.

 3. a concurrent hash map `pathVersion`, mapping between the file name without suffix and the most current version of file in cache.

Upon `close()` of the file, it will be moved to the head of the cache.

## Chunking

To ensure fetching of large files does not overflow the heap memory limit, I 
implemented chunking to fetch large files chunk by chunk, chunk size is 
set to be 64000 bytes.

## Dependencies

This provides the libraries and classes needed for Project 2.  

The tools directory contains binary tools that perform I/O operations.
These will work on Linux x86 64-bit platforms (e.g., Andrew servers).
These are a subset ofthe tools used in Project 1.

The lib directory has lib440lib.so.  This is an interposition library
that will redirect file operations to RPC calls. It is used just like
mylib.so in Project 1:
	LD_PRELOAD=lib/lib440lib.so tools/440read foo
	(Use env if you are not running bash).
This will connect to a proxy port specified in proxyport15440
environment variable.  

Note: the protocol between the interposition library and the 
provided code for the proxy uses a shared secret pin to restrict
who is allowed to connect.  You must set the pin15440 environment 
variable to a secret 9-digit number of your choice.

The lib directory also has the RPCreceiver class and its support
interfaces.  This class implements the stubs in Java compatiable with
lib440lib.so.  Your proxy code should make use of RPCreceiver to
interface with the clients. 

The doc directory has autogenerated javadoc documentation on
RPCreceiver and related classes. 

The sample directory has a simple skeleton implementation of a proxy
class, that shows how to interface to RPCreceiver.  To compile the sample,
make sure your CLASSPATH environment variable includes the absolute paths
to the lib and sample directories:
	export CLASSPATH=$PWD/lib:$PWD/sample
	(Use setenv if not using bash).
Then cd into the sample directory and run make.  Now you can run the 
skeleton proxy using:
	pin15440=ZZZZZZZZZ proxyport15440=XXXX java Proxy
The pin15440 variable should be the same 9-digit number as above.
Running a tool with the LD_PRELOAD of lib440lib.so will connect to the
Proxy, though none of the operations are actually implemented.  This
sample also shows how to compile a java program using a Makefile.  


